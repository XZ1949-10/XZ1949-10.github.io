# Lambda表达式 
C++11中的Lambda表达式用于**定义并创建匿名的函数对象**，以简化编程工作。下面看一下Lambda表达式的基本构成。
## 基本构成
首先是Lambda的基本结构：
> \[capture\](parameters) mutable ->return-type 
>{
>statement
>}

整体的结构可以表示为：\[函数对象参数\](操作符重载函数参数)mutable ->返回值{函数体}。下面依次介绍各个部分的定义及用法。

## 函数对象参数
\[] ,用这个方括号标识一个Lambda表达式的开始，这一部分**必须存在，不能省略**。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的**局部变量**（包括Lambda所在类的this）。
```c++
  int a=1;
  [](){
    cout<<a<<endl;
  }();
```
在这个例子中，函数对象为空，访问不到a，程序会报错。（最后加一个括号是直接调用）函数对象参数有以下形式：
* 空。没有使用任何函数对象参数。
* =。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是**值传递方式**（相当于编译器自动为我们按值传递了所有局部变量）。**这种方式最为常用**。
* &。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是**引用传递方式**（相当于编译器自动为我们按引用传递了所有局部变量）。
* this。函数体内可以使用Lambda所在类中的成员变量。
* a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。
* &a。将a按引用进行传递。=，&a, &b。除a和b按引用进行传递外，其他参数都按值进行传递。	&, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。

常用的方式就第二种和第三种。其它的方式根据具体的情况进行选择。

## 操作符重载函数参数
标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&a,&b)）两种方式进行传递。这个就类似与普通函数的形参。

## 可修改标示符
**mutable**声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。
```C++
int a=1;
    //不可修改
  [=](){
    a=2;
  }();
  //可以修改
   [=]()mutable{
    a=2;
  }();
```
只是对值的拷贝进行修改，函数外部变量的值仍未改变。
## 函数返回值
->返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。
## 函数体
{}，标识函数的实现，这部分不能省略，但函数体可以为空。

## Lambda作为返回值
在C++11中只能使用std::function指定返回值，将欲返回的lambda表达式转换成function对象。
```C++
auto num = [](int i, int j){ return i - j; };
int main(){
    cout<<num(1,2);
}
```
上述是将Lambda作为一个对象，然后用auto自动转换类型，同时可以指定类型也就是function对象。
```C++
 function<int(int,int)> num = [](int i, int j){ return i - j; };
  cout<<num(1,2);
```
这个模板对象中需要传入函数返回值类型和形参类型，通常使用auto进行自动转换。
```C++
std::function<void(int)> func(){
	return [] (int e) { std::cout << e; };
  }
func()(10);
```
这个例子是将Lambda作为函数的返回值。
## 总结
Lambda还有许多种用处，通常也可以作为STL种算法的参数传入，用于处理一些逻辑较为简单的函数结构，例如比较大小等。
```C++
std::sort(v.begin(), v.end(), [] ( int n1, int n2 ) { return n1 > n2; });
```
这个例子就是用sort算法，并利用Lambda进行排序。